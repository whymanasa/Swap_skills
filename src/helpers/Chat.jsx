import React, { useEffect, useState } from 'react';
import { db } from '../../firebase-config'; // Import Firestore
import { useParams } from 'react-router-dom'; // Import useParams to get the recipient token
import { collection, query, where, onSnapshot, addDoc, getDocs } from 'firebase/firestore';
import '../styles/Chat.css'; // Import the CSS file

function Chat({ currentUserId }) { // Accept currentUserId as a prop
  const { recipientToken } = useParams(); // Get the recipient token from the URL
  const [recipientId, setRecipientId] = useState(null);
  const [recipientName, setRecipientName] = useState(''); // State to store recipient's name
  const [messages, setMessages] = useState([]);
  const [messageContent, setMessageContent] = useState('');

  useEffect(() => {
    const fetchRecipientId = async () => {
      const profilesCollection = collection(db, 'profile');
      const profilesQuery = query(profilesCollection, where('token', '==', recipientToken));
      const profilesSnapshot = await getDocs(profilesQuery);
      profilesSnapshot.forEach((doc) => {
        setRecipientId(doc.id); // Set the recipient ID based on the token
        setRecipientName(doc.data().name); // Set the recipient's name from the document data
      });
    };

    fetchRecipientId();
  }, [recipientToken]);

  useEffect(() => {
    if (!recipientId) return; // Exit if recipient ID is not available

    // Generate chatId based on currentUserId and recipientId
    const chatId = generateChatId(currentUserId, recipientId);

    const fetchMessages = async () => {
      const messagesQuery = query(collection(db, 'Messages'), where('chatId', '==', chatId));
      const unsubscribe = onSnapshot(messagesQuery, (querySnapshot) => {
        const messagesData = [];
        querySnapshot.forEach((doc) => {
          messagesData.push({ id: doc.id, ...doc.data() });
        });
        setMessages(messagesData);
      });

      return () => unsubscribe(); // Cleanup subscription on unmount
    };

    fetchMessages();
  }, [recipientId, currentUserId]);

  const generateChatId = (userId1, userId2) => {
    const sortedIds = [userId1, userId2].sort(); // Sort to ensure consistent ordering
    return `${sortedIds[0]}_${sortedIds[1]}`; // e.g., "userA_userB"
  };

  const handleSendMessage = async () => {
    if (messageContent.trim() === '') return; // Prevent sending empty messages

    const chatId = generateChatId(currentUserId, recipientId); // Generate chatId

    try {
      const newMessageRef = await addDoc(collection(db, 'Messages'), {
        senderId: currentUserId, // Include senderId
        recipientId: recipientId, // Include recipientId
        content: messageContent, // Message content
        timestamp: new Date(), // Timestamp
        chatId: chatId, // Include chatId in the message document
      });

      const messageId = newMessageRef.id; // This is the unique message ID generated by Firestore
      console.log('Message ID:', messageId);
      console.log('Chat ID:', chatId);

      setMessageContent(''); // Clear the input after sending
    } catch (error) {
      console.error('Error sending message: ', error);
    }
  };

  return (
    <div className="chat-container">
      <h2 className="chat-header">Chat with {recipientName}</h2>
      <div>
        {messages.slice().reverse().map((msg) => (
          <div key={msg.id} className="message">
            <p className="sender">{msg.senderId === currentUserId ? 'You' : recipientName}:</p>
            <p>{msg.content}</p>
            <br/>
          </div>
        ))}
      </div>
      <div className="input-container">
        <input
          type="text"
          value={messageContent}
          onChange={(e) => setMessageContent(e.target.value)}
          placeholder="Type your message"
        />
        <button onClick={handleSendMessage}>Send</button>
      </div>
    </div>
  );
}

export default Chat;
